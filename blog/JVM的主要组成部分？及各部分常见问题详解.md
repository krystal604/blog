首先JVM包含三大部分
1. 运行时数据区
2. 类加载系统
3. 执行引擎

一、运行时数据区
运行时数据区在jdk 1.7 以前主要分为：

栈区（线程私有）
堆区（线程共享）
本地方法栈（线程私有）
程序计数器（线程私有）
方法区（线程共享）
栈区
栈区 主要由栈帧组成，每执行一个方法就会向栈去中添加一个栈帧
栈帧主要包括 方法的局部变量、动态链接、方法出口的数据。

堆区
用于存放对象的区，new的对象都会放到堆区中

本地方法栈
因为java语言底层是c写的 所以又很多native方法，主要就是存放本地方法的栈。

程序计数器
它可以看作是当前线程所执行的字节码的行号指示器，记录当前代码执行到哪。

方法区
它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

在JDK1.8后方法区不在JVM的内存中，而是迁移至直接内存，由元空间所取代
主要原因就是 类加载等信息大小不确定 容易浪费空间

二、类加载系统
主要功能：查找和验证.class文件 并完成对象的创建 以及内存的分配

类加载的过程？
类加载一共需要七个步骤

加载
验证
准备
解析
初始化
使用
卸载
同时 验证 准备 解析 三个步骤又被统称为链接。
这是我们普遍认为的一个类加载顺序，但是验证起始在加载就已经开始了，他是一个贯穿全局的步骤。
类加载器有哪些？
启动类加载器bootstrap ClassLoader
Ext ClassLoader
App ClassLoader
自定义 ClassLoader
JVM的双亲委派模型
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。

因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

为什么要设计双亲委派模式
防止核心类库被修改
避免重复加载
保证类的唯一性
三、执行引擎
主要包含两部分 ： 即时编译器 和 垃圾回收器两部分

即时编译器
将字节码翻译成cpu指令

垃圾回收器
如果判断哪个对象是垃圾对象？
引用计数法，可达性分析
要自己会分析哪些对象可以是GC ROOT对象，GC ROOT有一个特例：老年代的对象引用了新生代中的对象，那么这个对象也可 以作为GC ROOT
在Java语言中，可以作为GCRoots的对象包括下面几种：
(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。

(2). 方法区中的类静态属性引用的对象。

(3). 方法区中常量引用的对象。

(4). 本地方法栈中JNI(Native方法)引用的对象。

垃圾回收算法
1.标记清除
2.标记整理
3.复制
4.分代回收

CMS执行流程
口诀法：C初并重清（初始标记、并发标记、重新标记、并发清除）
整个过程分为 4 个步骤，包括：
初始标记 :仅仅只是标记一下 GCRoots 能直接关联到的对象，速度很快，需要停顿（STW-Stoptheworld）。

并发标记：从 GCRoot 开始对堆中对象进行可达性分析，找到存活对象，它在整个回收过程中耗时最长，不需要停顿。

重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿(STW)。这个阶段的停顿时间一般 会比初始标记阶段稍长一些，但远比并发标记的时间短。

并发清除：不需要停顿。基于标记清楚发

G1 回收过程
G1 回收器的运作过程大致可分为四个步骤:

初始标记(会STW):仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对 象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成 的，所以G1收集器在这个阶段实际并没有额外的停顿。
并发标记:从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象 图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完 成以后，还要重新处理在并发时有引用变动的对象。
最终标记(会STW):对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的 对象。
清理阶段(会STW):更新Region的统计数据，对各个Region的回收价值和成本进行排 序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回 收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整 个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条 回收器线程并行完成的。
CMS 和 G1的区别
两个垃圾回收器虽然都是基于分代回收，但是 CMS是物理意义上的真正分代回收，而G1 由于把内存分成了小的内存块，所以他是逻辑意义上的分代回收
CMS 是最求最短的停顿时间 STW的时间不可控制，而G1 是最求最高的效率，可以指定STW时间，G1 会记录每一个内存块回收垃圾所需的时间以及能回收的垃圾，从而确定在指定时间内能回收最多的垃圾
CMS是基于标记清楚算法 会形成大量的垃圾碎片 ， 而G1 宏观上看是标记整理法 而 微观上看是复制算法
Minor GC 和 Full GC 有什么不同呢?
Minor GC:只收集新生代的GC。
Full GC: 收集整个堆，包括 新生代，老年代，永久代(在 JDK 1.8及以后，永久代被移除，换 为metaspace 元空间)等所有部分的模式。
Minor GC触发条件:当Eden区满时，触发Minor GC。 Full GC触发条件:
通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之 前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为 触发full GC。 老年代空间不够分配新的内存(或永久代空间不足，但只是JDK1.7有的，这也是用元空 间来取代永久代的原因，可以减少Full GC的频率，减少GC负担，提升其效率)。 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则 把该对象转存到老年代，且老年代的可用内存小于该对象大小。 调用System.gc时，系统建议执行Full GC，但是不必然执行。

强引用、软引用、弱引用、虚引用是什么，有什么区别?
强引用，就是普通的对象引用关系，如 String s = new String(“ConstXiong”) 软引用，用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对 象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。 SoftReference 实现 弱引用，相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾 回收时，无论内存是否充足，都会回收被弱引用关联的对象。WeakReference 实现 虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃 圾回收的活动
